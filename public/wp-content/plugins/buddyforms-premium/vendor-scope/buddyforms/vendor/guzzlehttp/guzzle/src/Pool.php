<?php
 namespace tk\GuzzleHttp; use tk\GuzzleHttp\Promise as P; use tk\GuzzleHttp\Promise\EachPromise; use tk\GuzzleHttp\Promise\PromiseInterface; use tk\GuzzleHttp\Promise\PromisorInterface; use tk\Psr\Http\Message\RequestInterface; class Pool implements \tk\GuzzleHttp\Promise\PromisorInterface { private $each; public function __construct(\tk\GuzzleHttp\ClientInterface $client, $requests, array $config = []) { if (!isset($config['concurrency'])) { $config['concurrency'] = 25; } if (isset($config['options'])) { $opts = $config['options']; unset($config['options']); } else { $opts = []; } $iterable = \tk\GuzzleHttp\Promise\Create::iterFor($requests); $requests = static function () use($iterable, $client, $opts) { foreach ($iterable as $key => $rfn) { if ($rfn instanceof \tk\Psr\Http\Message\RequestInterface) { (yield $key => $client->sendAsync($rfn, $opts)); } elseif (\is_callable($rfn)) { (yield $key => $rfn($opts)); } else { throw new \InvalidArgumentException('Each value yielded by the iterator must be a Psr7\\Http\\Message\\RequestInterface or a callable that returns a promise that fulfills with a Psr7\\Message\\Http\\ResponseInterface object.'); } } }; $this->each = new \tk\GuzzleHttp\Promise\EachPromise($requests(), $config); } public function promise() : \tk\GuzzleHttp\Promise\PromiseInterface { return $this->each->promise(); } public static function batch(\tk\GuzzleHttp\ClientInterface $client, $requests, array $options = []) : array { $res = []; self::cmpCallback($options, 'fulfilled', $res); self::cmpCallback($options, 'rejected', $res); $pool = new static($client, $requests, $options); $pool->promise()->wait(); \ksort($res); return $res; } private static function cmpCallback(array &$options, string $name, array &$results) : void { if (!isset($options[$name])) { $options[$name] = static function ($v, $k) use(&$results) { $results[$k] = $v; }; } else { $currentFn = $options[$name]; $options[$name] = static function ($v, $k) use(&$results, $currentFn) { $currentFn($v, $k); $results[$k] = $v; }; } } } 